<!DOCTYPE html>
<html>
 
<head>
    <meta charset="utf-8">
    <script type="text/javascript" src="/ACM/js/head.js"></script>
    <link rel="stylesheet" type="text/css" charset="utf-8" media="screen" href="/hello/pastebin.css">
	<link rel="stylesheet" type="text/css" href="/ACM/css/right.css">
	<title>一维树状数组</title>
</head>
 
<body>

	
	
										
<div class="ACMright">
	<center>
	<h1>一维树状数组</h1>
	</center>
	
		树状数组这种数据结构利用二进制来优化区间。<br />
<br />
假设我们要维护区间&nbsp[1,n]<br />
<br />
定义树状数组的第i个元素维护了区间[i&(i-1)+1，i]<br />
<br />
&nbsp<br />
<br />
那么他究竟可以解决哪些区间问题？<br />
<br />
先考虑点更新，区间查询：<br />
<br />
点更新的话要解一个不定不等式：i&(i-1)&lt=x&lt=i<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp如果更新点x，就要更新树状数组对应的所有第i个元素<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp可以证明如果i1是一个解，且存在另一个大于i1的最小的解i2，则i2=i1+i1&(-i1)。笔者不想证明。<br />
<br />
区间查询因情况不定：<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp既然定义树状数组的第i个元素维护了区间[i&(i-1)+1，i]，那么第j=i&(i-1)个元素将维护区间[j&(j-1)+1，i&(i-1)]......<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp可以证明任何一个前缀区间都可以用有限（Olgn）个树状数组元素来维护。笔者不想证明。<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp故我们可以很容易解决前缀区间和，前缀区间最值。<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp任意区间和满足区间减法，容易处理。<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp任意区间最值却不满足，但我们可以递归处理。<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp利用原区间与树状数组共同维护<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp若x&lt=y&(-y)<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp则query(x,y)-&gtquery(x,y&(-y))和query(y&(-y)+1,y);<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp若x&gty&(-y)<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp则query(x,y)-&gtquery(x,y-1)和y这个点的单点值<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp但建议迭代实现<br />
<br />
再考虑区间更新点查询<br />
<br />
这个常用于区间和，<br />
<br />
对于序列a[1],a[2],a[3]...(以后简写为序列a)用于维护区间[1,N]；定义序列a的前i项和表示我们维护区间的点i的值。<br />
<br />
可以证明序列a唯一存在，笔者不想证明。<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp如果我们要更新区间[x,y]，只用修改a[x]和a[y+1]的值<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp如果我们要查询区间点i的值，只用查询序列a的前i项和<br />
<br />
这里已经转移到对新序列a的点修改区间查询了，over<br />
<br />
最后考虑区间更新区间查询<br />
<br />
这个也常用于区间和，<br />
<br />
此处序列a与上面的序列a一样。<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp如果我们要更新区间[x,y]，只用修改a[x]和a[y+1]的值<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp如果我们要查询区间[1,i&nbsp]，只用查询序列a的前i项和的前i项和(多几个字）<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp可以证明下述结论<br />
<br />

&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp <img alt="\sum_{i=1}^{N}\sum_{j=1}^{i} a_{j}=\sum_{j=1}^{N} (N+1-j)a_{j} =(N+1)\sum_{j=1}^{N} a_{j}-\sum_{j=1}^{N} ja_{j}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%5Csum_%7Bi%3D1%7D%5E%7BN%7D%5Csum_%7Bj%3D1%7D%5E%7Bi%7D%20a_%7Bj%7D%3D%5Csum_%7Bj%3D1%7D%5E%7BN%7D%20%28N&amp;plus;1-j%29a_%7Bj%7D%20%3D%28N&amp;plus;1%29%5Csum_%7Bj%3D1%7D%5E%7BN%7D%20a_%7Bj%7D-%5Csum_%7Bj%3D1%7D%5E%7BN%7D%20ja_%7Bj%7D" /><br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp很明显变成了查询序列a的前缀和以及序列a[1],2a[2],3a[3],4a[4]...的前缀和<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp那么我们再为序列a[1],2a[2],3a[3],4a[4]...也搞一个点更新区间查询树状数组来维护就行了<br />
<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp于是前缀区间查询已经解决，任意区间查询用区间减法就可以得到<br />
<br />
最后附上代码<br />
<br />
<span style="color: green;font: 20px;">//点更新区间查询,最大可用范围[1,N），实际使用[1,n]</span><br />
<span style="color: green;font: 20px;">//初始化N，n，初始化tree[]为0</span><br />
<span style="color: green;font: 20px;">//函数输入，函数返回值输出</span><br />
<span style="color: blue;font: 20px;">const</span>&nbsp<span style="color: blue;font: 20px;">int</span>&nbspN;<br />
<span style="color: blue;font: 20px;">int</span>&nbspn;<br />
<span style="color: blue;font: 20px;">int</span>&nbsptree[N];<br />
<br />
<span style="color: blue;font: 20px;">void</span>&nbspadd(<span style="color: blue;font: 20px;">int</span>&nbspk,<span style="color: blue;font: 20px;">int</span>&nbspd){<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">for</span>(<span style="color: blue;font: 20px;">int</span>&nbspi=k;i&lt=n;i+=i&-i)tree[i]+=d;<br />
}<br />
<span style="color: blue;font: 20px;">int</span>&nbspsigma(<span style="color: blue;font: 20px;">int</span>&nbspk){<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">int</span>&nbspret=0;<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">for</span>(<span style="color: blue;font: 20px;">int</span>&nbspi=k;i;i-=i&-i)ret+=tree[i];<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">return</span>&nbspret;<br />
}<br />
<span style="color: blue;font: 20px;">int</span>&nbspsigma(<span style="color: blue;font: 20px;">int</span>&nbspu,<span style="color: blue;font: 20px;">int</span>&nbspv){<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">return</span>&nbspsigma(v)-sigma(u-1);<br />
}<br />
<span style="color: green;font: 20px;">///////////////////////////////////////////////////////////////</span><br />
<br />
<span style="color: green;font: 20px;">//区间更新点查询,最大可用范围[1,N）,实际使用[1,n]</span><br />
<span style="color: green;font: 20px;">//初始化N，n初始化tree[]为0</span><br />
<span style="color: green;font: 20px;">//函数输入，函数返回值输出</span><br />
<span style="color: blue;font: 20px;">const</span>&nbsp<span style="color: blue;font: 20px;">int</span>&nbspN;<br />
<span style="color: blue;font: 20px;">int</span>&nbspn;<br />
<span style="color: blue;font: 20px;">int</span>&nbsptree[N];<br />
<br />
<span style="color: blue;font: 20px;">void</span>&nbspadd(<span style="color: blue;font: 20px;">int</span>&nbspk,<span style="color: blue;font: 20px;">int</span>&nbspd){<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">for</span>(<span style="color: blue;font: 20px;">int</span>&nbspi=k;i&lt=n;i+=i&-i)tree[i]+=d;<br />
}<br />
<span style="color: blue;font: 20px;">void</span>&nbspadd(<span style="color: blue;font: 20px;">int</span>&nbspu,<span style="color: blue;font: 20px;">int</span>&nbspv,<span style="color: blue;font: 20px;">int</span>&nbspd){<br />
&nbsp&nbsp&nbsp&nbspadd(u,d);<br />
&nbsp&nbsp&nbsp&nbspadd(v+1,-d);<br />
}<br />
<span style="color: blue;font: 20px;">int</span>&nbspsigma(<span style="color: blue;font: 20px;">int</span>&nbspk){<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">int</span>&nbspret=0;<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">for</span>(<span style="color: blue;font: 20px;">int</span>&nbspi=k;i;i-=i&-i)ret+=tree[i];<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">return</span>&nbspret;<br />
}<br />
<span style="color: green;font: 20px;">/////////////////////////////////////////////////////////////////</span><br />
<br />
<br />
<br />
<span style="color: green;font: 20px;">//区间更新区间查询,最大可用范围[1,N）,实际使用[1,n]</span><br />
<span style="color: green;font: 20px;">//初始化N，n初始化tree[]、tree2[]为0</span><br />
<span style="color: green;font: 20px;">//函数输入，函数返回值输出</span><br />
<span style="color: blue;font: 20px;">const</span>&nbsp<span style="color: blue;font: 20px;">int</span>&nbspN;<br />
<span style="color: blue;font: 20px;">int</span>&nbspn;<br />
<span style="color: blue;font: 20px;">int</span>&nbsptree[N],tree2[N];<br />
<br />
<span style="color: blue;font: 20px;">void</span>&nbspadd(<span style="color: blue;font: 20px;">int</span>&nbspk,<span style="color: blue;font: 20px;">int</span>&nbspd){<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">for</span>(<span style="color: blue;font: 20px;">int</span>&nbspi=k;i&lt=n;i+=i&-i)tree[i]+=d,tree2[i]+=k*d;<br />
}<br />
<span style="color: blue;font: 20px;">void</span>&nbspadd(<span style="color: blue;font: 20px;">int</span>&nbspu,<span style="color: blue;font: 20px;">int</span>&nbspv,<span style="color: blue;font: 20px;">int</span>&nbspd){<br />
&nbsp&nbsp&nbsp&nbspadd(u,d);<br />
&nbsp&nbsp&nbsp&nbspadd(v+1,-d);<br />
}<br />
<span style="color: blue;font: 20px;">int</span>&nbspsigma(<span style="color: blue;font: 20px;">int</span>&nbspk){<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">int</span>&nbspret=0;<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">for</span>(<span style="color: blue;font: 20px;">int</span>&nbspi=k;i;i-=i&-i)ret+=(k+1)*tree[i]-tree2[i];<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">return</span>&nbspret;<br />
}<br />
<span style="color: blue;font: 20px;">int</span>&nbspsigma(<span style="color: blue;font: 20px;">int</span>&nbspu,<span style="color: blue;font: 20px;">int</span>&nbspv){<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">return</span>&nbspsigma(v)-sigma(u-1);<br />
}<br />
<span style="color: green;font: 20px;">///////////////////////////////////////////////////////////////</span><br />
	
</body
	
	
	</div>
	
	
</html>
