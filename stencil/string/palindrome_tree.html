<!DOCTYPE html>
<html>
 
<head>
  <meta charset="utf-8">
	<script type="text/javascript" src="/ACM/js/link.js"></script>
	<title>palindrome_tree</title>
</head>

<body>
	<div id = "myweb">
		
<!--    啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦-->
<script type="text/javascript" src="/ACM/js/up_and_right.js"></script>
<!--    啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦-->
		     
     				     		<div id="left"><div id="left_in">
     			<center><h1>palindrome_tree</h1></center>
     			<div id="text"></div>
     			<div id="code">
     				
<pre><span class="k">struct</span> <span class="n">palindrome_tree</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span><span class="o">=</span><span class="mf">2e5</span><span class="o">+</span><span class="mi">5</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">nex</span><span class="p">[</span><span class="n">maxn</span><span class="p">][</span><span class="mi">26</span><span class="p">];</span><span class="c1">//字典树一样</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//回文长度</span>
    <span class="kt">int</span> <span class="n">suf</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//回文后缀</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//后缀数量</span>
    <span class="kt">int</span> <span class="n">last</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ecnt</span><span class="p">;</span><span class="c1">//除去根结点以外的节点数+1</span>
    
    <span class="kt">void</span> <span class="n">ini</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// memset(nex,0,sizeof(nex));</span>
        <span class="n">suf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">suf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">len</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//偶数回文</span>
        <span class="n">len</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//奇数回文</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">26</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">nex</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">nex</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ecnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        
        
        <span class="kt">int</span> <span class="n">len</span><span class="o">=</span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="n">calc</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="n">append</span><span class="p">(</span><span class="kt">int</span> <span class="n">cur</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">w</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="c1">///当前结点的值</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span><span class="c1">///上一次匹配到的回文后缀</span>
        <span class="k">while</span><span class="p">(</span> <span class="n">s</span><span class="p">[</span><span class="n">cur</span><span class="o">-</span><span class="n">len</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">cur</span><span class="p">])</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">suf</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
        <span class="c1">///现在p结点的cur儿子</span>
        <span class="c1">///要么是匹配成功的最长非自身回文后缀</span>
        <span class="c1">///要么是自身这一个字符</span>
        
        
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">nex</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">w</span><span class="p">])</span><span class="c1">///如果此回文后缀未出现过</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="o">++</span><span class="n">ecnt</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">suf</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
            
            <span class="c1">///我们来找他的suffix link回边</span>
            <span class="k">while</span><span class="p">(</span> <span class="n">s</span><span class="p">[</span><span class="n">cur</span><span class="o">-</span><span class="n">len</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">suf</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
            <span class="c1">///此时意味着找到了suffix link 是v的儿子</span>
            
            
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">26</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">nex</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">len</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span><span class="c1">///长度赋值，多两个</span>
            <span class="n">suf</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">nex</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">];</span><span class="c1">///回文保证此儿子一定存在，结点不为空</span>
            <span class="n">cnt</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            
            <span class="n">nex</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span><span class="c1">///创建的新结点与他的父亲连边</span>
        <span class="p">}</span>
        
        
        <span class="n">last</span> <span class="o">=</span> <span class="n">nex</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">w</span><span class="p">];</span><span class="c1">///这一次匹配到的回文后缀</span>
        <span class="n">cnt</span><span class="p">[</span><span class="n">last</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    
    
    <span class="kt">void</span> <span class="n">calc</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ecnt</span><span class="p">;</span> <span class="o">~</span><span class="n">i</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">)</span>
            <span class="n">cnt</span><span class="p">[</span><span class="n">suf</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="c1">///结点创建顺序保证了suf[i]&lt;i</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="n">tree</span><span class="p">;</span>
</pre>
	
     			</div>

     		</div>
     		
    </div>
</body>
</html>

