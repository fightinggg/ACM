<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>
			线段树
		</title>
		<style type="text/css">
			h1{text-align:center} 
		</style>
		<div id="head">
<h1 style="color: red;"> 线段树</h1>	
	</head>
		
	</div>

	
	

	<body>
		线段树是树状数组的强化版，它才是真正的树，它每次对区间进行二分，每一个深度都维护了整个区间，在同一深度里面，每个节点维护的区间长度大致相同，而每深入一层又大致比上一层多一倍的节点，故空间复杂度为Onlgn<br />
线段树一般采用二叉树结构<br />
每个非叶子节点维护一个区间[l,r]，令mid=(l+r)&gt&gt1,则该节点的左儿子维护[l,mid]，右儿子维护[mid+1,r]；<br />
每个叶子节点维护一个点；<br />
线段树是一颗接近平衡的树。&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<br />
因此当我们对于一个长度为n区间[l,r]进行操作的时候，我们就要操作所有与这些区间相关节点，这些节点数目接近2*N，笔者不想证明。要操作2*N个节点，，，，复杂度过高，，，问题无法解决。<br />
我们的操作相当于对树进行函数递归。<br />
这里我们把这个问题简化一下，对于那些节点对应区间属于[l,r]的我们分为一类，对于那些节点对应区间与[l,r]有交集，但不是[l,r]的子区间的节点我们分为第二类，第二类节点一定是某个第一类节点的父亲节点，借此我们可以在函数回溯时候利用区间加法处理，容易解决。<br />
我们容易发现第一类节点数目接近ON而第二类节点数目接近OlgN，第二类节点一个一个处理可以接受，第一类节点必须安排一下。可以证明第一类节点恰好可以用OlgN颗子树的所有节点唯一表达，笔者不想证明。<br />
在这里我们简化问题为对于OlgN个节点以及OlgN颗子树的操作，<br />
现在我们只需要考虑对某颗子树进行操作<br />
当我们进行修改的时候，我们试着只对该子树的根进行修改，并为其加入一个懒惰标记，表示他的所有子孙都有一个与懒惰标记有关的操作还未进行，(例如整段区间加上d，我们就设懒惰标记为d)&nbsp，如此区间修改就不用跑到叶子节点，就成了OlgN<br />
当我们进行查询时，每当我们查询一个节点，我们要查询的恰好为该节点所对应的区间，直接就处理了；如果不是该区间，而是该区间的某个子区间，那么我们考虑把该区间的懒惰标记下放到左右儿子，然后递归左右儿子，回溯答案。over<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<br />
为什么线段树快，因为它把区间分成OlgN个处理，并且每次在树上只跑了OlgN个节点，依据区间加法处理询问，依据区间加法回溯处理修改，依据懒惰标记不实时更新叶子节点。所以线段树快。<br />
为什么我在开头说线段树是树状数组的强化版，因为树状数组虽然能依据区间加法处理询问，也可以依靠区间加法处理更新，但是它的非叶子节点过少，导致复杂的数据维护时程序较为复杂，不太好处理。<br />
赋上代码（ACM采取堆结构模拟二叉树简化代码量）<br />
<span style="color: green;font: 20px;">//////////////////////////////////////////////</span><br />
<span style="color: green;font: 20px;">//初始化要求maxn&nbspn&nbsp</span><br />
<span style="color: green;font: 20px;">//注意修改注释部分代码即\345\217\257</span><br />
#define&nbspls&nbsp(u&lt&lt1)<br />
#define&nbsprs&nbsp(u&lt&lt1|1)<br />
#define&nbspml&nbsp((l+r)&gt&gt1)<br />
#define&nbspmr&nbsp(ml+1)<br />
<span style="color: blue;font: 20px;">const</span>&nbsp<span style="color: blue;font: 20px;">int</span>&nbspmaxn=5e4+10;<br />
<span style="color: blue;font: 20px;">int</span>&nbspn;<br />
<span style="color: blue;font: 20px;">int</span>&nbspa[maxn],tree[maxn&lt&lt2],lazy[maxn&lt&lt2];<br />
&nbsp<br />
<span style="color: blue;font: 20px;">void</span>&nbsppushdown(<span style="color: blue;font: 20px;">int</span>&nbspu,<span style="color: blue;font: 20px;">int</span>&nbspl,<span style="color: blue;font: 20px;">int</span>&nbspr){<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: green;font: 20px;">//lazy[ls]+=lazy[u];</span><br />
&nbsp&nbsp&nbsp&nbsp<span style="color: green;font: 20px;">//lazy[rs]+=lazy[u];</span><br />
&nbsp&nbsp&nbsp&nbsp<span style="color: green;font: 20px;">//tree[ls]+=lazy[u]*(ml-l+1);</span><br />
&nbsp&nbsp&nbsp&nbsp<span style="color: green;font: 20px;">//tree[rs]+=lazy[u]*(r-mr+1);</span><br />
&nbsp&nbsp&nbsp&nbsplazy[u]=0;<br />
}<br />
<span style="color: blue;font: 20px;">void</span>&nbsppushup(<span style="color: blue;font: 20px;">int</span>&nbspu){<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: green;font: 20px;">//tree[u]=tree[ls]+tree[rs];</span><br />
}<br />
<span style="color: blue;font: 20px;">void</span>&nbspbuild(<span style="color: blue;font: 20px;">int</span>&nbspl,<span style="color: blue;font: 20px;">int</span>&nbspr,<span style="color: blue;font: 20px;">int</span>&nbspu=1){<br />
&nbsp&nbsp&nbsp&nbsplazy[u]=0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">if</span>(l==r){<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsptree[u]=a[l];<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">return</span>;<br />
&nbsp&nbsp&nbsp&nbsp}<br />
&nbsp&nbsp&nbsp&nbspbuild(l,ml,ls);<br />
&nbsp&nbsp&nbsp&nbspbuild(mr,r,rs);<br />
&nbsp&nbsp&nbsp&nbsppushup(u);<br />
}<br />
<span style="color: blue;font: 20px;">void</span>&nbspupdate(<span style="color: blue;font: 20px;">int</span>&nbspql,<span style="color: blue;font: 20px;">int</span>&nbspqr,<span style="color: blue;font: 20px;">int</span>&nbspd,<span style="color: blue;font: 20px;">int</span>&nbspu=1,<span style="color: blue;font: 20px;">int</span>&nbspl=1,<span style="color: blue;font: 20px;">int</span>&nbspr=n){<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">if</span>(ql&lt=l&&r&lt=qr){<br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span style="color: green;font: 20px;">//tree[u]+=(qr-ql+1)*d;</span><br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span style="color: green;font: 20px;">//lazy[u]+=d;</span><br />
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">return</span>;<br />
&nbsp&nbsp&nbsp&nbsp}<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">if</span>(ql&lt=ml)update(ql,qr,d,ls,l,ml);<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">if</span>(qr&gt=mr)update(ql,qr,d,rs,mr,r);<br />
&nbsp&nbsp&nbsp&nbsppushup(u);<br />
}<br />
<span style="color: blue;font: 20px;">int</span>&nbspquery(<span style="color: blue;font: 20px;">int</span>&nbspql,<span style="color: blue;font: 20px;">int</span>&nbspqr,<span style="color: blue;font: 20px;">int</span>&nbspu=1,<span style="color: blue;font: 20px;">int</span>&nbspl=1,<span style="color: blue;font: 20px;">int</span>&nbspr=n){<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">if</span>(ql&lt=l&&r&lt=qr)<span style="color: blue;font: 20px;">return</span>&nbsptree[u];<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">if</span>(lazy[u])pushdown(u,l,r);<br />
&nbsp&nbsp&nbsp&nbspint&nbspret=0;<span style="color: green;font: 20px;">//返回也值搞一下\357\274\233</span><br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">if</span>(ql&lt=ml)ret+=query(ql,qr,ls,l,ml);<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">if</span>(qr&gt=mr)ret+=query(ql,qr,rs,mr,r);<br />
&nbsp&nbsp&nbsp&nbsp<span style="color: blue;font: 20px;">return</span>&nbspret;<br />
}<br />
<span style="color: green;font: 20px;">/////////////////////////////////////////////////</span><br />
.......	<br />
	</body>
</html>
